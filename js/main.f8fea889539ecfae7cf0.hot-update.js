"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatesharkgame"]("main",{

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function() {

eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar solve = function (cavity, remaining) {\n    // Divide the target number minus 1 by 4 and take the remainder\n    // (or modulus, for the math nerds), as well as keeping the quotient handy.\n    // (18-1)/4 is 4 with a remainder of 1. This remainder is important,\n    // but so is the quotient, so keep 1 and 4 in mind.\n    var target = remaining - cavity - 1;\n    var rem = target % 4;\n    var quot = Math.floor((target - 1) / 4);\n    return { rem: rem, quot: quot };\n};\nvar sleep = function (ms) { return new Promise(function (res) { return setTimeout(res, ms); }); };\nvar main = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var scale, canvasContainer, hitboxes, maxWidth, maxHeight, actualWidth, actualHeight, images, scaledImages, makeImg, scaledImagesWithImages, makeCanvas, scaledImagesWithImagesWithCanvases, drawImg, state, clickLock, setInstructions, resetButton, _drawHitboxen;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                scale = 1.5;\n                canvasContainer = document.getElementById(\"shark-game\");\n                if (!canvasContainer) {\n                    throw new Error(\"Container not found\");\n                }\n                hitboxes = {\n                    ids: {},\n                    hitboxes: {},\n                };\n                maxWidth = 390;\n                maxHeight = 404;\n                actualWidth = 0;\n                actualHeight = 0;\n                images = __spreadArray([\n                    {\n                        id: \"background\",\n                        src: \"background.png\",\n                        width: 394,\n                        left: 29,\n                        top: 29,\n                    },\n                    {\n                        id: \"frame\",\n                        src: \"frame.png\",\n                        width: 448,\n                        left: 0,\n                        top: 0,\n                    },\n                    { id: \"shark\", src: \"shark.png\", width: 396, left: 30, top: 28 }\n                ], __spreadArray([], Array(20), true).map(function (_, index) {\n                    var i = index + 1;\n                    return {\n                        id: \"tooth-\".concat(i),\n                        src: i < 10 ? \"tooth_0\".concat(i, \".png\") : \"tooth_\".concat(i, \".png\"),\n                        width: 392,\n                        left: 30,\n                        top: 30,\n                    };\n                }), true);\n                scaledImages = images.map(function (_a) {\n                    var width = _a.width, left = _a.left, top = _a.top, rest = __rest(_a, [\"width\", \"left\", \"top\"]);\n                    return (__assign({ width: Math.floor(width * scale), height: Math.floor((maxHeight / maxWidth) * width * scale), left: Math.floor(left * scale), top: Math.floor(top * scale) }, rest));\n                });\n                // find the largest dimesntions and set the canvas width/height to that\n                scaledImages.forEach(function (_a) {\n                    var width = _a.width, height = _a.height;\n                    if (actualWidth < width) {\n                        actualWidth = width;\n                    }\n                    if (actualHeight < height) {\n                        actualHeight = height;\n                    }\n                });\n                canvasContainer.style.position = \"relative\";\n                canvasContainer.style.width = \"\".concat(actualWidth, \"px\");\n                canvasContainer.style.height = \"\".concat(actualHeight, \"px\");\n                makeImg = function (image) { return __awaiter(void 0, void 0, void 0, function () {\n                    var id, src, width, height, left, top, container, img;\n                    return __generator(this, function (_a) {\n                        id = image.id, src = image.src, width = image.width, height = image.height, left = image.left, top = image.top;\n                        container = document.createElement(\"div\");\n                        img = document.createElement(\"img\");\n                        img.src = \"images/\".concat(src);\n                        container.appendChild(img);\n                        return [2 /*return*/, new Promise(function (resolve) {\n                                var onLoad = function (e) {\n                                    if (id.startsWith(\"tooth\") && !hitboxes.ids[id]) {\n                                        hitboxes.ids[id] = true;\n                                        var pixelFinder = document.createElement(\"canvas\");\n                                        pixelFinder.width = actualWidth;\n                                        pixelFinder.height = actualHeight;\n                                        var pxlCtx = pixelFinder.getContext(\"2d\");\n                                        if (!pxlCtx) {\n                                            throw new Error(\"Something wonky with this context yo\");\n                                        }\n                                        pxlCtx.drawImage(img, left, top, width, height);\n                                        var imgd = pxlCtx.getImageData(0, 0, actualWidth, actualHeight);\n                                        var pix = imgd.data;\n                                        for (var x = 0; x < actualWidth; x++) {\n                                            for (var y = 0; y < actualHeight; y++) {\n                                                var index = (y * actualWidth + x) * 4;\n                                                var alpha = pix[index + 3];\n                                                if (alpha > 1) {\n                                                    hitboxes.hitboxes[\"\".concat(x, \"-\").concat(y)] = id;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    resolve(__assign(__assign({}, image), { image: img }));\n                                    img.removeEventListener(\"load\", onLoad);\n                                };\n                                img.addEventListener(\"load\", onLoad);\n                            })];\n                    });\n                }); };\n                return [4 /*yield*/, Promise.all(scaledImages.map(makeImg))];\n            case 1:\n                scaledImagesWithImages = _a.sent();\n                makeCanvas = function (image) {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.style.position = \"absolute\";\n                    canvas.style.top = \"0\";\n                    canvas.style.left = \"0\";\n                    canvas.style.background = \"transparent\";\n                    canvas.width = actualWidth;\n                    canvas.height = actualHeight;\n                    var ctx = canvas.getContext(\"2d\");\n                    if (!ctx) {\n                        throw new Error(\"Something wonky with this context yo\");\n                    }\n                    ctx.imageSmoothingEnabled = false;\n                    canvasContainer.appendChild(canvas);\n                    return __assign(__assign({}, image), { canvas: canvas, ctx: ctx });\n                };\n                scaledImagesWithImagesWithCanvases = scaledImagesWithImages.map(makeCanvas);\n                drawImg = function (img) {\n                    var ctx = img.ctx, image = img.image, left = img.left, top = img.top, width = img.width, height = img.height, _a = img.tint, tint = _a === void 0 ? null : _a, clear = img.clear;\n                    if (clear) {\n                        ctx.clearRect(0, 0, actualWidth, actualHeight);\n                    }\n                    else if (tint) {\n                        var color = tint.color, _b = tint.alpha, alpha = _b === void 0 ? 0.5 : _b;\n                        var backBuffer = document.createElement(\"canvas\");\n                        backBuffer.width = actualWidth;\n                        backBuffer.height = actualHeight;\n                        var btx = backBuffer.getContext(\"2d\");\n                        if (!btx) {\n                            throw new Error(\"Something wonky with this context yo\");\n                        }\n                        btx.clearRect(0, 0, actualWidth, actualHeight);\n                        btx.drawImage(image, left, top, width, height);\n                        // Now we'll multiply a rectangle of your chosen color\n                        btx.fillStyle = color;\n                        btx.globalCompositeOperation = \"multiply\";\n                        btx.fillRect(0, 0, actualWidth, actualHeight);\n                        btx.globalAlpha = alpha;\n                        btx.globalCompositeOperation = \"destination-in\";\n                        btx.drawImage(image, left, top, width, height);\n                        ctx.drawImage(backBuffer, 0, 0, actualWidth, actualHeight);\n                    }\n                    else {\n                        ctx.drawImage(image, left, top, width, height);\n                    }\n                };\n                scaledImagesWithImagesWithCanvases.forEach(function (img) { return drawImg(img); });\n                state = { state: \"select-cavity\" };\n                clickLock = { lock: null };\n                setInstructions = function () {\n                    var instructionsContent = document.getElementById(\"instructions-content\");\n                    if (!instructionsContent) {\n                        throw new Error(\"Instructions content area not found\");\n                    }\n                    switch (state.state) {\n                        case \"select-cavity\": {\n                            instructionsContent.textContent = \"Select the tooth with the cavity!\";\n                            break;\n                        }\n                        case \"select-tooth\": {\n                            // TODO: Try to always count from the same side.\n                            var rem = solve(21 - state.cavity, 21 - (state.selected || 0)).rem;\n                            instructionsContent.textContent = \"Select the currently played tooth!\\nIf it's your turn, then play \".concat(rem || 1, \"!\");\n                            break;\n                        }\n                        case \"win\": {\n                            instructionsContent.textContent = \"If it's your turn, then you've won!\";\n                            break;\n                        }\n                    }\n                };\n                resetButton = document.getElementById(\"reset\");\n                if (!resetButton) {\n                    throw new Error(\"Reset button not found\");\n                }\n                resetButton.addEventListener(\"click\", function () { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (!clickLock.lock) return [3 /*break*/, 2];\n                                return [4 /*yield*/, clickLock.lock];\n                            case 1:\n                                _a.sent();\n                                _a.label = 2;\n                            case 2:\n                                state = { state: \"select-cavity\" };\n                                scaledImagesWithImagesWithCanvases\n                                    .filter(function (i) { return i.id.startsWith(\"tooth\"); })\n                                    .map(drawImg);\n                                setInstructions();\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                canvasContainer.addEventListener(\"click\", function (e) { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (clickLock.lock !== null) {\n                                    return [2 /*return*/];\n                                }\n                                clickLock.lock = new Promise(function (res) { return __awaiter(void 0, void 0, void 0, function () {\n                                    var canvasRect, x, y, hitboxId, image, target, _loop_1, i;\n                                    var _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                canvasRect = canvasContainer.getBoundingClientRect();\n                                                x = Math.floor(e.offsetX);\n                                                y = Math.floor(e.offsetY);\n                                                hitboxId = hitboxes.hitboxes[\"\".concat(x, \"-\").concat(y)];\n                                                if (!hitboxId) return [3 /*break*/, 7];\n                                                image = scaledImagesWithImagesWithCanvases.find(function (_a) {\n                                                    var id = _a.id;\n                                                    return id === hitboxId;\n                                                });\n                                                if (!image) return [3 /*break*/, 6];\n                                                target = parseInt(hitboxId.split(\"-\")[1], 10);\n                                                if (!(state.state === \"select-cavity\")) return [3 /*break*/, 1];\n                                                drawImg(__assign(__assign({}, image), { tint: { color: \"#F00000\", alpha: 0.3 } }));\n                                                state = { state: \"select-tooth\", cavity: target, selected: null };\n                                                return [3 /*break*/, 6];\n                                            case 1:\n                                                if (!(target < state.cavity &&\n                                                    (state.selected == null || state.selected < target))) return [3 /*break*/, 6];\n                                                _loop_1 = function (i) {\n                                                    var image_1;\n                                                    return __generator(this, function (_c) {\n                                                        switch (_c.label) {\n                                                            case 0:\n                                                                image_1 = scaledImagesWithImagesWithCanvases.find(function (_a) {\n                                                                    var id = _a.id;\n                                                                    return id === \"tooth-\".concat(i);\n                                                                });\n                                                                if (!image_1) return [3 /*break*/, 2];\n                                                                drawImg(__assign(__assign({}, image_1), { clear: true }));\n                                                                return [4 /*yield*/, sleep(150)];\n                                                            case 1:\n                                                                _c.sent();\n                                                                _c.label = 2;\n                                                            case 2: return [2 /*return*/];\n                                                        }\n                                                    });\n                                                };\n                                                i = (_a = state.selected) !== null && _a !== void 0 ? _a : 1;\n                                                _b.label = 2;\n                                            case 2:\n                                                if (!(i <= target)) return [3 /*break*/, 5];\n                                                return [5 /*yield**/, _loop_1(i)];\n                                            case 3:\n                                                _b.sent();\n                                                _b.label = 4;\n                                            case 4:\n                                                i++;\n                                                return [3 /*break*/, 2];\n                                            case 5:\n                                                if (target + 1 === state.cavity) {\n                                                    state = {\n                                                        state: \"win\",\n                                                        cavity: state.cavity,\n                                                        selected: target,\n                                                    };\n                                                }\n                                                else {\n                                                    state = {\n                                                        state: \"select-tooth\",\n                                                        cavity: state.cavity,\n                                                        selected: target,\n                                                    };\n                                                }\n                                                _b.label = 6;\n                                            case 6:\n                                                setInstructions();\n                                                _b.label = 7;\n                                            case 7:\n                                                res();\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                }); });\n                                return [4 /*yield*/, clickLock.lock];\n                            case 1:\n                                _a.sent();\n                                clickLock.lock = null;\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                _drawHitboxen = function () {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.style.position = \"absolute\";\n                    canvas.style.top = \"0\";\n                    canvas.style.left = \"0\";\n                    canvas.style.background = \"transparent\";\n                    canvas.width = actualWidth;\n                    canvas.height = actualHeight;\n                    var ctx = canvas.getContext(\"2d\");\n                    if (!ctx) {\n                        throw new Error(\"Something wonky with this context yo\");\n                    }\n                    ctx.imageSmoothingEnabled = false;\n                    var img = ctx.getImageData(0, 0, actualWidth, actualHeight);\n                    var data = img.data;\n                    for (var hitboxId in hitboxes.hitboxes) {\n                        var _a = hitboxId.split(\"-\"), x = _a[0], y = _a[1];\n                        var index = parseInt(y, 10) * actualWidth + parseInt(x, 10);\n                        data[index * 4] = 255;\n                        data[index * 4 + 3] = 255;\n                    }\n                    ctx.putImageData(img, 0, 0);\n                    canvasContainer.appendChild(canvas);\n                };\n                return [2 /*return*/];\n        }\n    });\n}); };\nmain();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhcmtnYW1lLy4vc3JjL2luZGV4LnRzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIHNvbHZlID0gZnVuY3Rpb24gKGNhdml0eSwgcmVtYWluaW5nKSB7XG4gICAgLy8gRGl2aWRlIHRoZSB0YXJnZXQgbnVtYmVyIG1pbnVzIDEgYnkgNCBhbmQgdGFrZSB0aGUgcmVtYWluZGVyXG4gICAgLy8gKG9yIG1vZHVsdXMsIGZvciB0aGUgbWF0aCBuZXJkcyksIGFzIHdlbGwgYXMga2VlcGluZyB0aGUgcXVvdGllbnQgaGFuZHkuXG4gICAgLy8gKDE4LTEpLzQgaXMgNCB3aXRoIGEgcmVtYWluZGVyIG9mIDEuIFRoaXMgcmVtYWluZGVyIGlzIGltcG9ydGFudCxcbiAgICAvLyBidXQgc28gaXMgdGhlIHF1b3RpZW50LCBzbyBrZWVwIDEgYW5kIDQgaW4gbWluZC5cbiAgICB2YXIgdGFyZ2V0ID0gcmVtYWluaW5nIC0gY2F2aXR5IC0gMTtcbiAgICB2YXIgcmVtID0gdGFyZ2V0ICUgNDtcbiAgICB2YXIgcXVvdCA9IE1hdGguZmxvb3IoKHRhcmdldCAtIDEpIC8gNCk7XG4gICAgcmV0dXJuIHsgcmVtOiByZW0sIHF1b3Q6IHF1b3QgfTtcbn07XG52YXIgc2xlZXAgPSBmdW5jdGlvbiAobXMpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHNldFRpbWVvdXQocmVzLCBtcyk7IH0pOyB9O1xudmFyIG1haW4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2FsZSwgY2FudmFzQ29udGFpbmVyLCBoaXRib3hlcywgbWF4V2lkdGgsIG1heEhlaWdodCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCwgaW1hZ2VzLCBzY2FsZWRJbWFnZXMsIG1ha2VJbWcsIHNjYWxlZEltYWdlc1dpdGhJbWFnZXMsIG1ha2VDYW52YXMsIHNjYWxlZEltYWdlc1dpdGhJbWFnZXNXaXRoQ2FudmFzZXMsIGRyYXdJbWcsIHN0YXRlLCBjbGlja0xvY2ssIHNldEluc3RydWN0aW9ucywgcmVzZXRCdXR0b24sIF9kcmF3SGl0Ym94ZW47XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAxLjU7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaGFyay1nYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FudmFzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpdGJveGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBpZHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBoaXRib3hlczoge30sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IDM5MDtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSA0MDQ7XG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgaW1hZ2VzID0gX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcImJhY2tncm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogXCJiYWNrZ3JvdW5kLnBuZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDM5NCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDI5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAyOSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiZnJhbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogXCJmcmFtZS5wbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGlkOiBcInNoYXJrXCIsIHNyYzogXCJzaGFyay5wbmdcIiwgd2lkdGg6IDM5NiwgbGVmdDogMzAsIHRvcDogMjggfVxuICAgICAgICAgICAgICAgIF0sIF9fc3ByZWFkQXJyYXkoW10sIEFycmF5KDIwKSwgdHJ1ZSkubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRvb3RoLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogaSA8IDEwID8gXCJ0b290aF8wXCIuY29uY2F0KGksIFwiLnBuZ1wiKSA6IFwidG9vdGhfXCIuY29uY2F0KGksIFwiLnBuZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzOTIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMzAsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksIHRydWUpO1xuICAgICAgICAgICAgICAgIHNjYWxlZEltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ3aWR0aFwiLCBcImxlZnRcIiwgXCJ0b3BcIl0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKHsgd2lkdGg6IE1hdGguZmxvb3Iod2lkdGggKiBzY2FsZSksIGhlaWdodDogTWF0aC5mbG9vcigobWF4SGVpZ2h0IC8gbWF4V2lkdGgpICogd2lkdGggKiBzY2FsZSksIGxlZnQ6IE1hdGguZmxvb3IobGVmdCAqIHNjYWxlKSwgdG9wOiBNYXRoLmZsb29yKHRvcCAqIHNjYWxlKSB9LCByZXN0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgbGFyZ2VzdCBkaW1lc250aW9ucyBhbmQgc2V0IHRoZSBjYW52YXMgd2lkdGgvaGVpZ2h0IHRvIHRoYXRcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFdpZHRoIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGFjdHVhbFdpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChhY3R1YWxIZWlnaHQsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgbWFrZUltZyA9IGZ1bmN0aW9uIChpbWFnZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkLCBzcmMsIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgY29udGFpbmVyLCBpbWc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gaW1hZ2UuaWQsIHNyYyA9IGltYWdlLnNyYywgd2lkdGggPSBpbWFnZS53aWR0aCwgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0LCBsZWZ0ID0gaW1hZ2UubGVmdCwgdG9wID0gaW1hZ2UudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gXCJpbWFnZXMvXCIuY29uY2F0KHNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKFwidG9vdGhcIikgJiYgIWhpdGJveGVzLmlkc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRib3hlcy5pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWxGaW5kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsRmluZGVyLndpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxGaW5kZXIuaGVpZ2h0ID0gYWN0dWFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBweGxDdHggPSBwaXhlbEZpbmRlci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFweGxDdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdvbmt5IHdpdGggdGhpcyBjb250ZXh0IHlvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweGxDdHguZHJhd0ltYWdlKGltZywgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nZCA9IHB4bEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeCA9IGltZ2QuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGFjdHVhbFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhY3R1YWxIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gKHkgKiBhY3R1YWxXaWR0aCArIHgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IHBpeFtpbmRleCArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdGJveGVzLmhpdGJveGVzW1wiXCIuY29uY2F0KHgsIFwiLVwiKS5jb25jYXQoeSldID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbWFnZSksIHsgaW1hZ2U6IGltZyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChzY2FsZWRJbWFnZXMubWFwKG1ha2VJbWcpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VzV2l0aEltYWdlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBtYWtlQ2FudmFzID0gZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gYWN0dWFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3b25reSB3aXRoIHRoaXMgY29udGV4dCB5b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGltYWdlKSwgeyBjYW52YXM6IGNhbnZhcywgY3R4OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzID0gc2NhbGVkSW1hZ2VzV2l0aEltYWdlcy5tYXAobWFrZUNhbnZhcyk7XG4gICAgICAgICAgICAgICAgZHJhd0ltZyA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGltZy5jdHgsIGltYWdlID0gaW1nLmltYWdlLCBsZWZ0ID0gaW1nLmxlZnQsIHRvcCA9IGltZy50b3AsIHdpZHRoID0gaW1nLndpZHRoLCBoZWlnaHQgPSBpbWcuaGVpZ2h0LCBfYSA9IGltZy50aW50LCB0aW50ID0gX2EgPT09IHZvaWQgMCA/IG51bGwgOiBfYSwgY2xlYXIgPSBpbWcuY2xlYXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aW50LmNvbG9yLCBfYiA9IHRpbnQuYWxwaGEsIGFscGhhID0gX2IgPT09IHZvaWQgMCA/IDAuNSA6IF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhY2tCdWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja0J1ZmZlci53aWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja0J1ZmZlci5oZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnR4ID0gYmFja0J1ZmZlci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3b25reSB3aXRoIHRoaXMgY29udGV4dCB5b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0eC5jbGVhclJlY3QoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZHJhd0ltYWdlKGltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlJ2xsIG11bHRpcGx5IGEgcmVjdGFuZ2xlIG9mIHlvdXIgY2hvc2VuIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJtdWx0aXBseVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnR4LmZpbGxSZWN0KDAsIDAsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnR4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnR4LmRyYXdJbWFnZShpbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja0J1ZmZlciwgMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24gKGltZykgeyByZXR1cm4gZHJhd0ltZyhpbWcpOyB9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgc3RhdGU6IFwic2VsZWN0LWNhdml0eVwiIH07XG4gICAgICAgICAgICAgICAgY2xpY2tMb2NrID0geyBsb2NrOiBudWxsIH07XG4gICAgICAgICAgICAgICAgc2V0SW5zdHJ1Y3Rpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25zQ29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5zdHJ1Y3Rpb25zLWNvbnRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5zdHJ1Y3Rpb25zQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5zdHJ1Y3Rpb25zIGNvbnRlbnQgYXJlYSBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdC1jYXZpdHlcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc0NvbnRlbnQudGV4dENvbnRlbnQgPSBcIlNlbGVjdCB0aGUgdG9vdGggd2l0aCB0aGUgY2F2aXR5IVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdC10b290aFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVHJ5IHRvIGFsd2F5cyBjb3VudCBmcm9tIHRoZSBzYW1lIHNpZGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbSA9IHNvbHZlKDIxIC0gc3RhdGUuY2F2aXR5LCAyMSAtIChzdGF0ZS5zZWxlY3RlZCB8fCAwKSkucmVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc0NvbnRlbnQudGV4dENvbnRlbnQgPSBcIlNlbGVjdCB0aGUgY3VycmVudGx5IHBsYXllZCB0b290aCFcXG5JZiBpdCdzIHlvdXIgdHVybiwgdGhlbiBwbGF5IFwiLmNvbmNhdChyZW0gfHwgMSwgXCIhXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndpblwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudC50ZXh0Q29udGVudCA9IFwiSWYgaXQncyB5b3VyIHR1cm4sIHRoZW4geW91J3ZlIHdvbiFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzZXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc2V0XCIpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzZXRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZXQgYnV0dG9uIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzZXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xpY2tMb2NrLmxvY2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGlja0xvY2subG9ja107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBzdGF0ZTogXCJzZWxlY3QtY2F2aXR5XCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VzV2l0aEltYWdlc1dpdGhDYW52YXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5pZC5zdGFydHNXaXRoKFwidG9vdGhcIik7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGRyYXdJbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbnN0cnVjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWNrTG9jay5sb2NrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tMb2NrLmxvY2sgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhc1JlY3QsIHgsIHksIGhpdGJveElkLCBpbWFnZSwgdGFyZ2V0LCBfbG9vcF8xLCBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVjdCA9IGNhbnZhc0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKGUub2Zmc2V0WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5mbG9vcihlLm9mZnNldFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0Ym94SWQgPSBoaXRib3hlcy5oaXRib3hlc1tcIlwiLmNvbmNhdCh4LCBcIi1cIikuY29uY2F0KHkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGl0Ym94SWQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLmZpbmQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gX2EuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkID09PSBoaXRib3hJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwYXJzZUludChoaXRib3hJZC5zcGxpdChcIi1cIilbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0YXRlLnN0YXRlID09PSBcInNlbGVjdC1jYXZpdHlcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0ltZyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW1hZ2UpLCB7IHRpbnQ6IHsgY29sb3I6IFwiI0YwMDAwMFwiLCBhbHBoYTogMC4zIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHN0YXRlOiBcInNlbGVjdC10b290aFwiLCBjYXZpdHk6IHRhcmdldCwgc2VsZWN0ZWQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0YXJnZXQgPCBzdGF0ZS5jYXZpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuc2VsZWN0ZWQgPT0gbnVsbCB8fCBzdGF0ZS5zZWxlY3RlZCA8IHRhcmdldCkpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXzEgPSBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLmZpbmQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPT09IFwidG9vdGgtXCIuY29uY2F0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2VfMSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0ltZyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW1hZ2VfMSksIHsgY2xlYXI6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNsZWVwKDE1MCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAoX2EgPSBzdGF0ZS5zZWxlY3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8PSB0YXJnZXQpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKGkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCArIDEgPT09IHN0YXRlLmNhdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJ3aW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F2aXR5OiBzdGF0ZS5jYXZpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJzZWxlY3QtdG9vdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F2aXR5OiBzdGF0ZS5jYXZpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNsaWNrTG9jay5sb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tMb2NrLmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICBfZHJhd0hpdGJveGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGFjdHVhbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb21ldGhpbmcgd29ua3kgd2l0aCB0aGlzIGNvbnRleHQgeW9cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBpbWcuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaGl0Ym94SWQgaW4gaGl0Ym94ZXMuaGl0Ym94ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGhpdGJveElkLnNwbGl0KFwiLVwiKSwgeCA9IF9hWzBdLCB5ID0gX2FbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludCh5LCAxMCkgKiBhY3R1YWxXaWR0aCArIHBhcnNlSW50KHgsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKiA0XSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5tYWluKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("774976e663206182c2e4")
/******/ })();
/******/ 
/******/ }
);