"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatesharkgame"]("main",{

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar solve = function (cavity, remaining) {\n    // Divide the target number minus 1 by 4 and take the remainder\n    // (or modulus, for the math nerds), as well as keeping the quotient handy.\n    // (18-1)/4 is 4 with a remainder of 1. This remainder is important,\n    // but so is the quotient, so keep 1 and 4 in mind.\n    var target = remaining - cavity - 1;\n    var rem = target % 4;\n    var quot = Math.floor((target - 1) / 4);\n    return { rem: rem, quot: quot };\n};\nvar sleep = function (ms) { return new Promise(function (res) { return setTimeout(res, ms); }); };\nvar main = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var scale, canvasContainer, hitboxes, maxWidth, maxHeight, actualWidth, actualHeight, images, scaledImages, makeImg, scaledImagesWithImages, makeCanvas, scaledImagesWithImagesWithCanvases, drawImg, state, clickLock, resetButton, _drawHitboxen;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                scale = 1.5;\n                canvasContainer = document.getElementById(\"shark-game\");\n                if (!canvasContainer) {\n                    throw new Error(\"Container not found\");\n                }\n                hitboxes = {\n                    ids: {},\n                    hitboxes: {},\n                };\n                maxWidth = 390;\n                maxHeight = 404;\n                actualWidth = 0;\n                actualHeight = 0;\n                images = __spreadArray([\n                    {\n                        id: \"background\",\n                        src: \"background.png\",\n                        width: 394,\n                        left: 29,\n                        top: 29,\n                    },\n                    {\n                        id: \"frame\",\n                        src: \"frame.png\",\n                        width: 448,\n                        left: 0,\n                        top: 0,\n                    },\n                    { id: \"shark\", src: \"shark.png\", width: 392, left: 30, top: 30 }\n                ], __spreadArray([], Array(20), true).map(function (_, index) {\n                    var i = index + 1;\n                    return {\n                        id: \"tooth-\".concat(i),\n                        src: i < 10 ? \"tooth_0\".concat(i, \".png\") : \"tooth_\".concat(i, \".png\"),\n                        width: 392,\n                        left: 30,\n                        top: 30,\n                    };\n                }), true);\n                scaledImages = images.map(function (_a) {\n                    var width = _a.width, left = _a.left, top = _a.top, rest = __rest(_a, [\"width\", \"left\", \"top\"]);\n                    return (__assign({ width: Math.floor(width * scale), height: Math.floor((maxHeight / maxWidth) * width * scale), left: Math.floor(left * scale), top: Math.floor(top * scale) }, rest));\n                });\n                // find the largest dimesntions and set the canvas width/height to that\n                scaledImages.forEach(function (_a) {\n                    var width = _a.width, height = _a.height;\n                    if (actualWidth < width) {\n                        actualWidth = width;\n                    }\n                    if (actualHeight < height) {\n                        actualHeight = height;\n                    }\n                });\n                canvasContainer.style.position = \"relative\";\n                canvasContainer.style.width = \"\".concat(actualWidth, \"px\");\n                canvasContainer.style.height = \"\".concat(actualHeight, \"px\");\n                makeImg = function (image) { return __awaiter(void 0, void 0, void 0, function () {\n                    var id, src, width, height, left, top, container, img;\n                    return __generator(this, function (_a) {\n                        id = image.id, src = image.src, width = image.width, height = image.height, left = image.left, top = image.top;\n                        container = document.createElement(\"div\");\n                        img = document.createElement(\"img\");\n                        img.src = \"images/\".concat(src);\n                        container.appendChild(img);\n                        return [2 /*return*/, new Promise(function (resolve) {\n                                var onLoad = function (e) {\n                                    if (id.startsWith(\"tooth\") && !hitboxes.ids[id]) {\n                                        hitboxes.ids[id] = true;\n                                        var pixelFinder = document.createElement(\"canvas\");\n                                        pixelFinder.width = actualWidth;\n                                        pixelFinder.height = actualHeight;\n                                        var pxlCtx = pixelFinder.getContext(\"2d\");\n                                        if (!pxlCtx) {\n                                            throw new Error(\"Something wonky with this context yo\");\n                                        }\n                                        pxlCtx.drawImage(img, left, top, width, height);\n                                        var imgd = pxlCtx.getImageData(0, 0, actualWidth, actualHeight);\n                                        var pix = imgd.data;\n                                        for (var x = 0; x < actualWidth; x++) {\n                                            for (var y = 0; y < actualHeight; y++) {\n                                                var index = (y * actualWidth + x) * 4;\n                                                var alpha = pix[index + 3];\n                                                if (alpha > 1) {\n                                                    hitboxes.hitboxes[\"\".concat(x, \"-\").concat(y)] = id;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    resolve(__assign(__assign({}, image), { image: img }));\n                                    img.removeEventListener(\"load\", onLoad);\n                                };\n                                img.addEventListener(\"load\", onLoad);\n                            })];\n                    });\n                }); };\n                return [4 /*yield*/, Promise.all(scaledImages.map(makeImg))];\n            case 1:\n                scaledImagesWithImages = _a.sent();\n                makeCanvas = function (image) {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.style.position = \"absolute\";\n                    canvas.style.top = \"0\";\n                    canvas.style.left = \"0\";\n                    canvas.style.background = \"transparent\";\n                    canvas.width = actualWidth;\n                    canvas.height = actualHeight;\n                    var ctx = canvas.getContext(\"2d\");\n                    if (!ctx) {\n                        throw new Error(\"Something wonky with this context yo\");\n                    }\n                    ctx.imageSmoothingEnabled = false;\n                    canvasContainer.appendChild(canvas);\n                    return __assign(__assign({}, image), { canvas: canvas, ctx: ctx });\n                };\n                scaledImagesWithImagesWithCanvases = scaledImagesWithImages.map(makeCanvas);\n                drawImg = function (img) {\n                    var ctx = img.ctx, image = img.image, left = img.left, top = img.top, width = img.width, height = img.height, _a = img.tint, tint = _a === void 0 ? null : _a, clear = img.clear;\n                    if (clear) {\n                        ctx.clearRect(0, 0, actualWidth, actualHeight);\n                    }\n                    else if (tint) {\n                        var color = tint.color, _b = tint.alpha, alpha = _b === void 0 ? 0.5 : _b;\n                        var backBuffer = document.createElement(\"canvas\");\n                        backBuffer.width = actualWidth;\n                        backBuffer.height = actualHeight;\n                        var btx = backBuffer.getContext(\"2d\");\n                        if (!btx) {\n                            throw new Error(\"Something wonky with this context yo\");\n                        }\n                        btx.clearRect(0, 0, actualWidth, actualHeight);\n                        btx.drawImage(image, left, top, width, height);\n                        // Now we'll multiply a rectangle of your chosen color\n                        btx.fillStyle = color;\n                        btx.globalCompositeOperation = \"multiply\";\n                        btx.fillRect(0, 0, actualWidth, actualHeight);\n                        btx.globalAlpha = alpha;\n                        btx.globalCompositeOperation = \"destination-in\";\n                        btx.drawImage(image, left, top, width, height);\n                        ctx.drawImage(backBuffer, 0, 0, actualWidth, actualHeight);\n                    }\n                    else {\n                        ctx.drawImage(image, left, top, width, height);\n                    }\n                };\n                scaledImagesWithImagesWithCanvases.forEach(function (img) { return drawImg(img); });\n                state = { state: \"select-cavity\" };\n                clickLock = { lock: null };\n                resetButton = document.getElementById(\"reset\");\n                if (!resetButton) {\n                    throw new Error(\"Reset button not found\");\n                }\n                resetButton.addEventListener(\"click\", function () { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (!clickLock.lock) return [3 /*break*/, 2];\n                                return [4 /*yield*/, clickLock.lock];\n                            case 1:\n                                _a.sent();\n                                _a.label = 2;\n                            case 2:\n                                state = { state: \"select-cavity\" };\n                                scaledImagesWithImagesWithCanvases\n                                    .filter(function (i) { return i.id.startsWith(\"tooth\"); })\n                                    .map(drawImg);\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                canvasContainer.addEventListener(\"click\", function (e) { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (clickLock.lock !== null) {\n                                    return [2 /*return*/];\n                                }\n                                clickLock.lock = new Promise(function (res) { return __awaiter(void 0, void 0, void 0, function () {\n                                    var canvasRect, x, y, hitboxId, image, target, _loop_1, i, instructionsContent, rem;\n                                    return __generator(this, function (_a) {\n                                        switch (_a.label) {\n                                            case 0:\n                                                canvasRect = canvasContainer.getBoundingClientRect();\n                                                x = Math.floor(e.offsetX);\n                                                y = Math.floor(e.offsetY);\n                                                hitboxId = hitboxes.hitboxes[\"\".concat(x, \"-\").concat(y)];\n                                                if (!hitboxId) return [3 /*break*/, 7];\n                                                image = scaledImagesWithImagesWithCanvases.find(function (_a) {\n                                                    var id = _a.id;\n                                                    return id === hitboxId;\n                                                });\n                                                if (!image) return [3 /*break*/, 6];\n                                                target = parseInt(hitboxId.split(\"-\")[1], 10);\n                                                if (!(state.state === \"select-cavity\")) return [3 /*break*/, 1];\n                                                drawImg(__assign(__assign({}, image), { tint: { color: \"#F00000\", alpha: 0.3 } }));\n                                                state = { state: \"select-tooth\", cavity: target, selected: null };\n                                                return [3 /*break*/, 6];\n                                            case 1:\n                                                if (!(target < state.cavity &&\n                                                    (state.selected == null || state.selected < target))) return [3 /*break*/, 6];\n                                                _loop_1 = function (i) {\n                                                    var image_1;\n                                                    return __generator(this, function (_b) {\n                                                        switch (_b.label) {\n                                                            case 0:\n                                                                image_1 = scaledImagesWithImagesWithCanvases.find(function (_a) {\n                                                                    var id = _a.id;\n                                                                    return id === \"tooth-\".concat(i);\n                                                                });\n                                                                if (!image_1) return [3 /*break*/, 2];\n                                                                drawImg(__assign(__assign({}, image_1), { clear: true }));\n                                                                return [4 /*yield*/, sleep(150)];\n                                                            case 1:\n                                                                _b.sent();\n                                                                _b.label = 2;\n                                                            case 2: return [2 /*return*/];\n                                                        }\n                                                    });\n                                                };\n                                                i = 1;\n                                                _a.label = 2;\n                                            case 2:\n                                                if (!(i <= target)) return [3 /*break*/, 5];\n                                                return [5 /*yield**/, _loop_1(i)];\n                                            case 3:\n                                                _a.sent();\n                                                _a.label = 4;\n                                            case 4:\n                                                i++;\n                                                return [3 /*break*/, 2];\n                                            case 5:\n                                                if (target + 1 === state.cavity) {\n                                                    state = {\n                                                        state: \"win\",\n                                                        cavity: state.cavity,\n                                                        selected: target,\n                                                    };\n                                                }\n                                                else {\n                                                    state = {\n                                                        state: \"select-tooth\",\n                                                        cavity: state.cavity,\n                                                        selected: target,\n                                                    };\n                                                }\n                                                _a.label = 6;\n                                            case 6:\n                                                instructionsContent = document.getElementById(\"instructions-content\");\n                                                if (!instructionsContent) {\n                                                    throw new Error(\"Instructions content area not found\");\n                                                }\n                                                switch (state.state) {\n                                                    case \"select-cavity\": {\n                                                        instructionsContent.textContent =\n                                                            \"Select the tooth with the cavity!\";\n                                                        break;\n                                                    }\n                                                    case \"select-tooth\": {\n                                                        rem = solve(21 - state.cavity, 21 - (state.selected || 0)).rem;\n                                                        instructionsContent.textContent = \"Select the currently played tooth!\\nIf it's your turn, then play \".concat(rem || 1, \"!\");\n                                                        break;\n                                                    }\n                                                    case \"win\": {\n                                                        instructionsContent.textContent = \"If it's your turn, then you've won!\";\n                                                        break;\n                                                    }\n                                                }\n                                                _a.label = 7;\n                                            case 7:\n                                                res();\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                }); });\n                                return [4 /*yield*/, clickLock.lock];\n                            case 1:\n                                _a.sent();\n                                clickLock.lock = null;\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                _drawHitboxen = function () {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.style.position = \"absolute\";\n                    canvas.style.top = \"0\";\n                    canvas.style.left = \"0\";\n                    canvas.style.background = \"transparent\";\n                    canvas.width = actualWidth;\n                    canvas.height = actualHeight;\n                    var ctx = canvas.getContext(\"2d\");\n                    if (!ctx) {\n                        throw new Error(\"Something wonky with this context yo\");\n                    }\n                    ctx.imageSmoothingEnabled = false;\n                    var img = ctx.getImageData(0, 0, actualWidth, actualHeight);\n                    var data = img.data;\n                    for (var hitboxId in hitboxes.hitboxes) {\n                        var _a = hitboxId.split(\"-\"), x = _a[0], y = _a[1];\n                        var index = parseInt(y, 10) * actualWidth + parseInt(x, 10);\n                        console.log({ x: x, y: y, index: index });\n                        data[index * 4] = 255;\n                        data[index * 4 + 3] = 255;\n                    }\n                    ctx.putImageData(img, 0, 0);\n                    canvasContainer.appendChild(canvas);\n                };\n                return [2 /*return*/];\n        }\n    });\n}); };\nmain();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDckMsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywwQkFBMEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDVSIsInNvdXJjZXMiOlsid2VicGFjazovL3NoYXJrZ2FtZS8uL3NyYy9pbmRleC50cz9lOTRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgc29sdmUgPSBmdW5jdGlvbiAoY2F2aXR5LCByZW1haW5pbmcpIHtcbiAgICAvLyBEaXZpZGUgdGhlIHRhcmdldCBudW1iZXIgbWludXMgMSBieSA0IGFuZCB0YWtlIHRoZSByZW1haW5kZXJcbiAgICAvLyAob3IgbW9kdWx1cywgZm9yIHRoZSBtYXRoIG5lcmRzKSwgYXMgd2VsbCBhcyBrZWVwaW5nIHRoZSBxdW90aWVudCBoYW5keS5cbiAgICAvLyAoMTgtMSkvNCBpcyA0IHdpdGggYSByZW1haW5kZXIgb2YgMS4gVGhpcyByZW1haW5kZXIgaXMgaW1wb3J0YW50LFxuICAgIC8vIGJ1dCBzbyBpcyB0aGUgcXVvdGllbnQsIHNvIGtlZXAgMSBhbmQgNCBpbiBtaW5kLlxuICAgIHZhciB0YXJnZXQgPSByZW1haW5pbmcgLSBjYXZpdHkgLSAxO1xuICAgIHZhciByZW0gPSB0YXJnZXQgJSA0O1xuICAgIHZhciBxdW90ID0gTWF0aC5mbG9vcigodGFyZ2V0IC0gMSkgLyA0KTtcbiAgICByZXR1cm4geyByZW06IHJlbSwgcXVvdDogcXVvdCB9O1xufTtcbnZhciBzbGVlcCA9IGZ1bmN0aW9uIChtcykgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gc2V0VGltZW91dChyZXMsIG1zKTsgfSk7IH07XG52YXIgbWFpbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjYWxlLCBjYW52YXNDb250YWluZXIsIGhpdGJveGVzLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0LCBpbWFnZXMsIHNjYWxlZEltYWdlcywgbWFrZUltZywgc2NhbGVkSW1hZ2VzV2l0aEltYWdlcywgbWFrZUNhbnZhcywgc2NhbGVkSW1hZ2VzV2l0aEltYWdlc1dpdGhDYW52YXNlcywgZHJhd0ltZywgc3RhdGUsIGNsaWNrTG9jaywgcmVzZXRCdXR0b24sIF9kcmF3SGl0Ym94ZW47XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAxLjU7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaGFyay1nYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmICghY2FudmFzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhaW5lciBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhpdGJveGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBpZHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBoaXRib3hlczoge30sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IDM5MDtcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSA0MDQ7XG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgaW1hZ2VzID0gX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcImJhY2tncm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogXCJiYWNrZ3JvdW5kLnBuZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDM5NCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDI5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAyOSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiZnJhbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogXCJmcmFtZS5wbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiA0NDgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IGlkOiBcInNoYXJrXCIsIHNyYzogXCJzaGFyay5wbmdcIiwgd2lkdGg6IDM5MiwgbGVmdDogMzAsIHRvcDogMzAgfVxuICAgICAgICAgICAgICAgIF0sIF9fc3ByZWFkQXJyYXkoW10sIEFycmF5KDIwKSwgdHJ1ZSkubWFwKGZ1bmN0aW9uIChfLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInRvb3RoLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogaSA8IDEwID8gXCJ0b290aF8wXCIuY29uY2F0KGksIFwiLnBuZ1wiKSA6IFwidG9vdGhfXCIuY29uY2F0KGksIFwiLnBuZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzOTIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAzMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMzAsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksIHRydWUpO1xuICAgICAgICAgICAgICAgIHNjYWxlZEltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IF9hLndpZHRoLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ3aWR0aFwiLCBcImxlZnRcIiwgXCJ0b3BcIl0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKHsgd2lkdGg6IE1hdGguZmxvb3Iod2lkdGggKiBzY2FsZSksIGhlaWdodDogTWF0aC5mbG9vcigobWF4SGVpZ2h0IC8gbWF4V2lkdGgpICogd2lkdGggKiBzY2FsZSksIGxlZnQ6IE1hdGguZmxvb3IobGVmdCAqIHNjYWxlKSwgdG9wOiBNYXRoLmZsb29yKHRvcCAqIHNjYWxlKSB9LCByZXN0KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgbGFyZ2VzdCBkaW1lc250aW9ucyBhbmQgc2V0IHRoZSBjYW52YXMgd2lkdGgvaGVpZ2h0IHRvIHRoYXRcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFdpZHRoIDwgd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbFdpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGFjdHVhbFdpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChhY3R1YWxIZWlnaHQsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgbWFrZUltZyA9IGZ1bmN0aW9uIChpbWFnZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkLCBzcmMsIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCwgY29udGFpbmVyLCBpbWc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gaW1hZ2UuaWQsIHNyYyA9IGltYWdlLnNyYywgd2lkdGggPSBpbWFnZS53aWR0aCwgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0LCBsZWZ0ID0gaW1hZ2UubGVmdCwgdG9wID0gaW1hZ2UudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gXCJpbWFnZXMvXCIuY29uY2F0KHNyYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Mb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZC5zdGFydHNXaXRoKFwidG9vdGhcIikgJiYgIWhpdGJveGVzLmlkc1tpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRib3hlcy5pZHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWxGaW5kZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsRmluZGVyLndpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxGaW5kZXIuaGVpZ2h0ID0gYWN0dWFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBweGxDdHggPSBwaXhlbEZpbmRlci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFweGxDdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdvbmt5IHdpdGggdGhpcyBjb250ZXh0IHlvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweGxDdHguZHJhd0ltYWdlKGltZywgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nZCA9IHB4bEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeCA9IGltZ2QuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGFjdHVhbFdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhY3R1YWxIZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gKHkgKiBhY3R1YWxXaWR0aCArIHgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IHBpeFtpbmRleCArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdGJveGVzLmhpdGJveGVzW1wiXCIuY29uY2F0KHgsIFwiLVwiKS5jb25jYXQoeSldID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbWFnZSksIHsgaW1hZ2U6IGltZyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChzY2FsZWRJbWFnZXMubWFwKG1ha2VJbWcpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VzV2l0aEltYWdlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBtYWtlQ2FudmFzID0gZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gYWN0dWFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3b25reSB3aXRoIHRoaXMgY29udGV4dCB5b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGltYWdlKSwgeyBjYW52YXM6IGNhbnZhcywgY3R4OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzID0gc2NhbGVkSW1hZ2VzV2l0aEltYWdlcy5tYXAobWFrZUNhbnZhcyk7XG4gICAgICAgICAgICAgICAgZHJhd0ltZyA9IGZ1bmN0aW9uIChpbWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGltZy5jdHgsIGltYWdlID0gaW1nLmltYWdlLCBsZWZ0ID0gaW1nLmxlZnQsIHRvcCA9IGltZy50b3AsIHdpZHRoID0gaW1nLndpZHRoLCBoZWlnaHQgPSBpbWcuaGVpZ2h0LCBfYSA9IGltZy50aW50LCB0aW50ID0gX2EgPT09IHZvaWQgMCA/IG51bGwgOiBfYSwgY2xlYXIgPSBpbWcuY2xlYXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSB0aW50LmNvbG9yLCBfYiA9IHRpbnQuYWxwaGEsIGFscGhhID0gX2IgPT09IHZvaWQgMCA/IDAuNSA6IF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJhY2tCdWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja0J1ZmZlci53aWR0aCA9IGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFja0J1ZmZlci5oZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnR4ID0gYmFja0J1ZmZlci5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyB3b25reSB3aXRoIHRoaXMgY29udGV4dCB5b1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0eC5jbGVhclJlY3QoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZHJhd0ltYWdlKGltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93IHdlJ2xsIG11bHRpcGx5IGEgcmVjdGFuZ2xlIG9mIHlvdXIgY2hvc2VuIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJtdWx0aXBseVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnR4LmZpbGxSZWN0KDAsIDAsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnR4Lmdsb2JhbEFscGhhID0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnR4LmRyYXdJbWFnZShpbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoYmFja0J1ZmZlciwgMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLmZvckVhY2goZnVuY3Rpb24gKGltZykgeyByZXR1cm4gZHJhd0ltZyhpbWcpOyB9KTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgc3RhdGU6IFwic2VsZWN0LWNhdml0eVwiIH07XG4gICAgICAgICAgICAgICAgY2xpY2tMb2NrID0geyBsb2NrOiBudWxsIH07XG4gICAgICAgICAgICAgICAgcmVzZXRCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlc2V0XCIpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzZXRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzZXQgYnV0dG9uIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzZXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xpY2tMb2NrLmxvY2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGlja0xvY2subG9ja107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBzdGF0ZTogXCJzZWxlY3QtY2F2aXR5XCIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VzV2l0aEltYWdlc1dpdGhDYW52YXNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5pZC5zdGFydHNXaXRoKFwidG9vdGhcIik7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGRyYXdJbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xpY2tMb2NrLmxvY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGlja0xvY2subG9jayA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzUmVjdCwgeCwgeSwgaGl0Ym94SWQsIGltYWdlLCB0YXJnZXQsIF9sb29wXzEsIGksIGluc3RydWN0aW9uc0NvbnRlbnQsIHJlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc1JlY3QgPSBjYW52YXNDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5mbG9vcihlLm9mZnNldFgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGguZmxvb3IoZS5vZmZzZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdGJveElkID0gaGl0Ym94ZXMuaGl0Ym94ZXNbXCJcIi5jb25jYXQoeCwgXCItXCIpLmNvbmNhdCh5KV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhpdGJveElkKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gc2NhbGVkSW1hZ2VzV2l0aEltYWdlc1dpdGhDYW52YXNlcy5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZCA9PT0gaGl0Ym94SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcGFyc2VJbnQoaGl0Ym94SWQuc3BsaXQoXCItXCIpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGF0ZS5zdGF0ZSA9PT0gXCJzZWxlY3QtY2F2aXR5XCIpKSByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdJbWcoX19hc3NpZ24oX19hc3NpZ24oe30sIGltYWdlKSwgeyB0aW50OiB7IGNvbG9yOiBcIiNGMDAwMDBcIiwgYWxwaGE6IDAuMyB9IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0geyBzdGF0ZTogXCJzZWxlY3QtdG9vdGhcIiwgY2F2aXR5OiB0YXJnZXQsIHNlbGVjdGVkOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGFyZ2V0IDwgc3RhdGUuY2F2aXR5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnNlbGVjdGVkID09IG51bGwgfHwgc3RhdGUuc2VsZWN0ZWQgPCB0YXJnZXQpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1hZ2VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV8xID0gc2NhbGVkSW1hZ2VzV2l0aEltYWdlc1dpdGhDYW52YXNlcy5maW5kKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkID09PSBcInRvb3RoLVwiLmNvbmNhdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlXzEpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdJbWcoX19hc3NpZ24oX19hc3NpZ24oe30sIGltYWdlXzEpLCB7IGNsZWFyOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzbGVlcCgxNTApXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8PSB0YXJnZXQpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKGkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCArIDEgPT09IHN0YXRlLmNhdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJ3aW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F2aXR5OiBzdGF0ZS5jYXZpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJzZWxlY3QtdG9vdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F2aXR5OiBzdGF0ZS5jYXZpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5zdHJ1Y3Rpb25zLWNvbnRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc3RydWN0aW9uc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnN0cnVjdGlvbnMgY29udGVudCBhcmVhIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0LWNhdml0eVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc0NvbnRlbnQudGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWxlY3QgdGhlIHRvb3RoIHdpdGggdGhlIGNhdml0eSFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3QtdG9vdGhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBzb2x2ZSgyMSAtIHN0YXRlLmNhdml0eSwgMjEgLSAoc3RhdGUuc2VsZWN0ZWQgfHwgMCkpLnJlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudC50ZXh0Q29udGVudCA9IFwiU2VsZWN0IHRoZSBjdXJyZW50bHkgcGxheWVkIHRvb3RoIVxcbklmIGl0J3MgeW91ciB0dXJuLCB0aGVuIHBsYXkgXCIuY29uY2F0KHJlbSB8fCAxLCBcIiFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2luXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudC50ZXh0Q29udGVudCA9IFwiSWYgaXQncyB5b3VyIHR1cm4sIHRoZW4geW91J3ZlIHdvbiFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGlja0xvY2subG9ja107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrTG9jay5sb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgX2RyYXdIaXRib3hlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdvbmt5IHdpdGggdGhpcyBjb250ZXh0IHlvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gaW1nLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhpdGJveElkIGluIGhpdGJveGVzLmhpdGJveGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBoaXRib3hJZC5zcGxpdChcIi1cIiksIHggPSBfYVswXSwgeSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoeSwgMTApICogYWN0dWFsV2lkdGggKyBwYXJzZUludCh4LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh7IHg6IHgsIHk6IHksIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKiA0XSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5tYWluKCk7XG5leHBvcnQge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("ba281608d171e65a8b74")
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ }
);