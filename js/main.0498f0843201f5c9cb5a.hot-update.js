"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdatesharkgame"]("main",{

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (undefined && undefined.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar solve = function (cavity, remaining) {\n    // Divide the target number minus 1 by 4 and take the remainder\n    // (or modulus, for the math nerds), as well as keeping the quotient handy.\n    // (18-1)/4 is 4 with a remainder of 1. This remainder is important,\n    // but so is the quotient, so keep 1 and 4 in mind.\n    var target = remaining - cavity - 1;\n    var rem = target % 4;\n    var quot = Math.floor((target - 1) / 4);\n    return { rem: rem, quot: quot };\n};\nvar sleep = function (ms) { return new Promise(function (res) { return setTimeout(res, ms); }); };\nvar main = function () { return __awaiter(void 0, void 0, void 0, function () {\n    var scale, canvasContainer, hitboxes, maxWidth, maxHeight, actualWidth, actualHeight, images, scaledImages, makeImg, scaledImagesWithImages, makeCanvas, scaledImagesWithImagesWithCanvases, drawImg, state, clickLock, resetButton, _drawHitboxen;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                scale = 1.5;\n                canvasContainer = document.getElementById(\"shark-game\");\n                if (!canvasContainer) {\n                    throw new Error(\"Container not found\");\n                }\n                hitboxes = {\n                    ids: {},\n                    hitboxes: {},\n                };\n                maxWidth = 390;\n                maxHeight = 404;\n                actualWidth = 0;\n                actualHeight = 0;\n                images = __spreadArray([\n                    {\n                        id: \"background\",\n                        src: \"background.png\",\n                        width: 394,\n                        left: 29,\n                        top: 29,\n                    },\n                    {\n                        id: \"frame\",\n                        src: \"frame.png\",\n                        width: 448,\n                        left: 0,\n                        top: 0,\n                    },\n                    { id: \"shark\", src: \"shark.png\", width: 392, left: 30, top: 30 }\n                ], __spreadArray([], Array(20), true).map(function (_, index) {\n                    var i = index + 1;\n                    return {\n                        id: \"tooth-\".concat(i),\n                        src: i < 10 ? \"tooth_0\".concat(i, \".png\") : \"tooth_\".concat(i, \".png\"),\n                        width: 392,\n                        left: 30,\n                        top: 30,\n                    };\n                }), true);\n                scaledImages = images.map(function (_a) {\n                    var width = _a.width, left = _a.left, top = _a.top, rest = __rest(_a, [\"width\", \"left\", \"top\"]);\n                    return (__assign({ width: Math.floor(width * scale), height: Math.floor((maxHeight / maxWidth) * width * scale), left: Math.floor(left * scale), top: Math.floor(top * scale) }, rest));\n                });\n                // find the largest dimesntions and set the canvas width/height to that\n                scaledImages.forEach(function (_a) {\n                    var width = _a.width, height = _a.height;\n                    if (actualWidth < width) {\n                        actualWidth = width;\n                    }\n                    if (actualHeight < height) {\n                        actualHeight = height;\n                    }\n                });\n                canvasContainer.style.position = \"relative\";\n                canvasContainer.style.width = \"\".concat(actualWidth, \"px\");\n                canvasContainer.style.height = \"\".concat(actualHeight, \"px\");\n                makeImg = function (image) { return __awaiter(void 0, void 0, void 0, function () {\n                    var id, src, width, height, left, top, container, img;\n                    return __generator(this, function (_a) {\n                        id = image.id, src = image.src, width = image.width, height = image.height, left = image.left, top = image.top;\n                        container = document.createElement(\"div\");\n                        img = document.createElement(\"img\");\n                        img.src = \"images/\".concat(src);\n                        container.appendChild(img);\n                        return [2 /*return*/, new Promise(function (resolve) {\n                                var onLoad = function (e) {\n                                    if (id.startsWith(\"tooth\") && !hitboxes.ids[id]) {\n                                        hitboxes.ids[id] = true;\n                                        var pixelFinder = document.createElement(\"canvas\");\n                                        pixelFinder.width = actualWidth;\n                                        pixelFinder.height = actualHeight;\n                                        var pxlCtx = pixelFinder.getContext(\"2d\");\n                                        if (!pxlCtx) {\n                                            throw new Error(\"Something wonky with this context yo\");\n                                        }\n                                        pxlCtx.drawImage(img, left, top, width, height);\n                                        var imgd = pxlCtx.getImageData(0, 0, actualWidth, actualHeight);\n                                        var pix = imgd.data;\n                                        for (var x = 0; x < actualWidth; x++) {\n                                            for (var y = 0; y < actualHeight; y++) {\n                                                var index = (y * actualWidth + x) * 4;\n                                                var alpha = pix[index + 3];\n                                                if (alpha > 1) {\n                                                    hitboxes.hitboxes[\"\".concat(x, \"-\").concat(y)] = id;\n                                                }\n                                            }\n                                        }\n                                    }\n                                    resolve(__assign(__assign({}, image), { image: img }));\n                                    img.removeEventListener(\"load\", onLoad);\n                                };\n                                img.addEventListener(\"load\", onLoad);\n                            })];\n                    });\n                }); };\n                return [4 /*yield*/, Promise.all(scaledImages.map(makeImg))];\n            case 1:\n                scaledImagesWithImages = _a.sent();\n                makeCanvas = function (image) {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.style.position = \"absolute\";\n                    canvas.style.top = \"0\";\n                    canvas.style.left = \"0\";\n                    canvas.style.background = \"transparent\";\n                    canvas.width = actualWidth;\n                    canvas.height = actualHeight;\n                    var ctx = canvas.getContext(\"2d\");\n                    if (!ctx) {\n                        throw new Error(\"Something wonky with this context yo\");\n                    }\n                    ctx.imageSmoothingEnabled = false;\n                    canvasContainer.appendChild(canvas);\n                    return __assign(__assign({}, image), { canvas: canvas, ctx: ctx });\n                };\n                scaledImagesWithImagesWithCanvases = scaledImagesWithImages.map(makeCanvas);\n                drawImg = function (img) {\n                    var ctx = img.ctx, image = img.image, left = img.left, top = img.top, width = img.width, height = img.height, _a = img.tint, tint = _a === void 0 ? null : _a, clear = img.clear;\n                    if (clear) {\n                        ctx.clearRect(0, 0, actualWidth, actualHeight);\n                    }\n                    else if (tint) {\n                        var color = tint.color, _b = tint.alpha, alpha = _b === void 0 ? 0.5 : _b;\n                        var backBuffer = document.createElement(\"canvas\");\n                        backBuffer.width = actualWidth;\n                        backBuffer.height = actualHeight;\n                        var btx = backBuffer.getContext(\"2d\");\n                        if (!btx) {\n                            throw new Error(\"Something wonky with this context yo\");\n                        }\n                        btx.clearRect(0, 0, actualWidth, actualHeight);\n                        btx.drawImage(image, left, top, width, height);\n                        // Now we'll multiply a rectangle of your chosen color\n                        btx.fillStyle = color;\n                        btx.globalCompositeOperation = \"multiply\";\n                        btx.fillRect(0, 0, actualWidth, actualHeight);\n                        btx.globalAlpha = alpha;\n                        btx.globalCompositeOperation = \"destination-in\";\n                        btx.drawImage(image, left, top, width, height);\n                        ctx.drawImage(backBuffer, 0, 0, actualWidth, actualHeight);\n                    }\n                    else {\n                        ctx.drawImage(image, left, top, width, height);\n                    }\n                };\n                scaledImagesWithImagesWithCanvases.forEach(function (img) { return drawImg(img); });\n                state = { state: \"select-cavity\" };\n                clickLock = { lock: null };\n                resetButton = document.getElementById(\"reset\");\n                if (!resetButton) {\n                    throw new Error(\"Reset button not found\");\n                }\n                resetButton.addEventListener(\"click\", function () { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (!clickLock.lock) return [3 /*break*/, 2];\n                                return [4 /*yield*/, clickLock.lock];\n                            case 1:\n                                _a.sent();\n                                _a.label = 2;\n                            case 2:\n                                state = { state: \"select-cavity\" };\n                                scaledImagesWithImagesWithCanvases\n                                    .filter(function (i) { return i.id.startsWith(\"tooth\"); })\n                                    .map(drawImg);\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                canvasContainer.addEventListener(\"click\", function (e) { return __awaiter(void 0, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                if (clickLock.lock !== null) {\n                                    return [2 /*return*/];\n                                }\n                                clickLock.lock = new Promise(function (res) { return __awaiter(void 0, void 0, void 0, function () {\n                                    var canvasRect, x, y, hitboxId, image, target, _loop_1, i, instructionsContent, rem;\n                                    var _a;\n                                    return __generator(this, function (_b) {\n                                        switch (_b.label) {\n                                            case 0:\n                                                canvasRect = canvasContainer.getBoundingClientRect();\n                                                x = Math.floor(e.offsetX);\n                                                y = Math.floor(e.offsetY);\n                                                hitboxId = hitboxes.hitboxes[\"\".concat(x, \"-\").concat(y)];\n                                                if (!hitboxId) return [3 /*break*/, 7];\n                                                image = scaledImagesWithImagesWithCanvases.find(function (_a) {\n                                                    var id = _a.id;\n                                                    return id === hitboxId;\n                                                });\n                                                if (!image) return [3 /*break*/, 6];\n                                                target = parseInt(hitboxId.split(\"-\")[1], 10);\n                                                if (!(state.state === \"select-cavity\")) return [3 /*break*/, 1];\n                                                drawImg(__assign(__assign({}, image), { tint: { color: \"#F00000\", alpha: 0.3 } }));\n                                                state = { state: \"select-tooth\", cavity: target, selected: null };\n                                                return [3 /*break*/, 6];\n                                            case 1:\n                                                if (!(target < state.cavity &&\n                                                    (state.selected == null || state.selected < target))) return [3 /*break*/, 6];\n                                                _loop_1 = function (i) {\n                                                    var image_1;\n                                                    return __generator(this, function (_c) {\n                                                        switch (_c.label) {\n                                                            case 0:\n                                                                image_1 = scaledImagesWithImagesWithCanvases.find(function (_a) {\n                                                                    var id = _a.id;\n                                                                    return id === \"tooth-\".concat(i);\n                                                                });\n                                                                if (!image_1) return [3 /*break*/, 2];\n                                                                drawImg(__assign(__assign({}, image_1), { clear: true }));\n                                                                return [4 /*yield*/, sleep(150)];\n                                                            case 1:\n                                                                _c.sent();\n                                                                _c.label = 2;\n                                                            case 2: return [2 /*return*/];\n                                                        }\n                                                    });\n                                                };\n                                                i = (_a = state.selected) !== null && _a !== void 0 ? _a : 1;\n                                                _b.label = 2;\n                                            case 2:\n                                                if (!(i <= target)) return [3 /*break*/, 5];\n                                                return [5 /*yield**/, _loop_1(i)];\n                                            case 3:\n                                                _b.sent();\n                                                _b.label = 4;\n                                            case 4:\n                                                i++;\n                                                return [3 /*break*/, 2];\n                                            case 5:\n                                                if (target + 1 === state.cavity) {\n                                                    state = {\n                                                        state: \"win\",\n                                                        cavity: state.cavity,\n                                                        selected: target,\n                                                    };\n                                                }\n                                                else {\n                                                    state = {\n                                                        state: \"select-tooth\",\n                                                        cavity: state.cavity,\n                                                        selected: target,\n                                                    };\n                                                }\n                                                _b.label = 6;\n                                            case 6:\n                                                instructionsContent = document.getElementById(\"instructions-content\");\n                                                if (!instructionsContent) {\n                                                    throw new Error(\"Instructions content area not found\");\n                                                }\n                                                switch (state.state) {\n                                                    case \"select-cavity\": {\n                                                        instructionsContent.textContent =\n                                                            \"Select the tooth with the cavity!\";\n                                                        break;\n                                                    }\n                                                    case \"select-tooth\": {\n                                                        rem = solve(21 - state.cavity, 21 - (state.selected || 0)).rem;\n                                                        instructionsContent.textContent = \"Select the currently played tooth!\\nIf it's your turn, then play \".concat(rem || 1, \"!\");\n                                                        break;\n                                                    }\n                                                    case \"win\": {\n                                                        instructionsContent.textContent = \"If it's your turn, then you've won!\";\n                                                        break;\n                                                    }\n                                                }\n                                                _b.label = 7;\n                                            case 7:\n                                                res();\n                                                return [2 /*return*/];\n                                        }\n                                    });\n                                }); });\n                                return [4 /*yield*/, clickLock.lock];\n                            case 1:\n                                _a.sent();\n                                clickLock.lock = null;\n                                return [2 /*return*/];\n                        }\n                    });\n                }); });\n                _drawHitboxen = function () {\n                    var canvas = document.createElement(\"canvas\");\n                    canvas.style.position = \"absolute\";\n                    canvas.style.top = \"0\";\n                    canvas.style.left = \"0\";\n                    canvas.style.background = \"transparent\";\n                    canvas.width = actualWidth;\n                    canvas.height = actualHeight;\n                    var ctx = canvas.getContext(\"2d\");\n                    if (!ctx) {\n                        throw new Error(\"Something wonky with this context yo\");\n                    }\n                    ctx.imageSmoothingEnabled = false;\n                    var img = ctx.getImageData(0, 0, actualWidth, actualHeight);\n                    var data = img.data;\n                    for (var hitboxId in hitboxes.hitboxes) {\n                        var _a = hitboxId.split(\"-\"), x = _a[0], y = _a[1];\n                        var index = parseInt(y, 10) * actualWidth + parseInt(x, 10);\n                        console.log({ x: x, y: y, index: index });\n                        data[index * 4] = 255;\n                        data[index * 4 + 3] = 255;\n                    }\n                    ctx.putImageData(img, 0, 0);\n                    canvasContainer.appendChild(canvas);\n                };\n                return [2 /*return*/];\n        }\n    });\n}); };\nmain();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFxQztBQUNyQyxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hhcmtnYW1lLy4vc3JjL2luZGV4LnRzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBzb2x2ZSA9IGZ1bmN0aW9uIChjYXZpdHksIHJlbWFpbmluZykge1xuICAgIC8vIERpdmlkZSB0aGUgdGFyZ2V0IG51bWJlciBtaW51cyAxIGJ5IDQgYW5kIHRha2UgdGhlIHJlbWFpbmRlclxuICAgIC8vIChvciBtb2R1bHVzLCBmb3IgdGhlIG1hdGggbmVyZHMpLCBhcyB3ZWxsIGFzIGtlZXBpbmcgdGhlIHF1b3RpZW50IGhhbmR5LlxuICAgIC8vICgxOC0xKS80IGlzIDQgd2l0aCBhIHJlbWFpbmRlciBvZiAxLiBUaGlzIHJlbWFpbmRlciBpcyBpbXBvcnRhbnQsXG4gICAgLy8gYnV0IHNvIGlzIHRoZSBxdW90aWVudCwgc28ga2VlcCAxIGFuZCA0IGluIG1pbmQuXG4gICAgdmFyIHRhcmdldCA9IHJlbWFpbmluZyAtIGNhdml0eSAtIDE7XG4gICAgdmFyIHJlbSA9IHRhcmdldCAlIDQ7XG4gICAgdmFyIHF1b3QgPSBNYXRoLmZsb29yKCh0YXJnZXQgLSAxKSAvIDQpO1xuICAgIHJldHVybiB7IHJlbTogcmVtLCBxdW90OiBxdW90IH07XG59O1xudmFyIHNsZWVwID0gZnVuY3Rpb24gKG1zKSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlcywgbXMpOyB9KTsgfTtcbnZhciBtYWluID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NhbGUsIGNhbnZhc0NvbnRhaW5lciwgaGl0Ym94ZXMsIG1heFdpZHRoLCBtYXhIZWlnaHQsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQsIGltYWdlcywgc2NhbGVkSW1hZ2VzLCBtYWtlSW1nLCBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzLCBtYWtlQ2FudmFzLCBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLCBkcmF3SW1nLCBzdGF0ZSwgY2xpY2tMb2NrLCByZXNldEJ1dHRvbiwgX2RyYXdIaXRib3hlbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzY2FsZSA9IDEuNTtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNoYXJrLWdhbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW52YXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFpbmVyIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGl0Ym94ZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkczoge30sXG4gICAgICAgICAgICAgICAgICAgIGhpdGJveGVzOiB7fSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1heFdpZHRoID0gMzkwO1xuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IDQwNDtcbiAgICAgICAgICAgICAgICBhY3R1YWxXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICBpbWFnZXMgPSBfX3NwcmVhZEFycmF5KFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwiYmFja2dyb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBcImJhY2tncm91bmQucG5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMzk0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMjksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDI5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJmcmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBcImZyYW1lLnBuZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDQ0OCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgaWQ6IFwic2hhcmtcIiwgc3JjOiBcInNoYXJrLnBuZ1wiLCB3aWR0aDogMzkyLCBsZWZ0OiAzMCwgdG9wOiAzMCB9XG4gICAgICAgICAgICAgICAgXSwgX19zcHJlYWRBcnJheShbXSwgQXJyYXkoMjApLCB0cnVlKS5tYXAoZnVuY3Rpb24gKF8sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwidG9vdGgtXCIuY29uY2F0KGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBpIDwgMTAgPyBcInRvb3RoXzBcIi5jb25jYXQoaSwgXCIucG5nXCIpIDogXCJ0b290aF9cIi5jb25jYXQoaSwgXCIucG5nXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDM5MixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAzMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2NhbGVkSW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGxlZnQgPSBfYS5sZWZ0LCB0b3AgPSBfYS50b3AsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIndpZHRoXCIsIFwibGVmdFwiLCBcInRvcFwiXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX19hc3NpZ24oeyB3aWR0aDogTWF0aC5mbG9vcih3aWR0aCAqIHNjYWxlKSwgaGVpZ2h0OiBNYXRoLmZsb29yKChtYXhIZWlnaHQgLyBtYXhXaWR0aCkgKiB3aWR0aCAqIHNjYWxlKSwgbGVmdDogTWF0aC5mbG9vcihsZWZ0ICogc2NhbGUpLCB0b3A6IE1hdGguZmxvb3IodG9wICogc2NhbGUpIH0sIHJlc3QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBsYXJnZXN0IGRpbWVzbnRpb25zIGFuZCBzZXQgdGhlIGNhbnZhcyB3aWR0aC9oZWlnaHQgdG8gdGhhdFxuICAgICAgICAgICAgICAgIHNjYWxlZEltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsV2lkdGggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0dWFsSGVpZ2h0IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQoYWN0dWFsV2lkdGgsIFwicHhcIik7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGFjdHVhbEhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgICAgICAgICBtYWtlSW1nID0gZnVuY3Rpb24gKGltYWdlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQsIHNyYywgd2lkdGgsIGhlaWdodCwgbGVmdCwgdG9wLCBjb250YWluZXIsIGltZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBpbWFnZS5pZCwgc3JjID0gaW1hZ2Uuc3JjLCB3aWR0aCA9IGltYWdlLndpZHRoLCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQsIGxlZnQgPSBpbWFnZS5sZWZ0LCB0b3AgPSBpbWFnZS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBcImltYWdlcy9cIi5jb25jYXQoc3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkLnN0YXJ0c1dpdGgoXCJ0b290aFwiKSAmJiAhaGl0Ym94ZXMuaWRzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdGJveGVzLmlkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbEZpbmRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxGaW5kZXIud2lkdGggPSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXhlbEZpbmRlci5oZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB4bEN0eCA9IHBpeGVsRmluZGVyLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXB4bEN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTb21ldGhpbmcgd29ua3kgd2l0aCB0aGlzIGNvbnRleHQgeW9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4bEN0eC5kcmF3SW1hZ2UoaW1nLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWdkID0gcHhsQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ID0gaW1nZC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgYWN0dWFsV2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGFjdHVhbEhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAoeSAqIGFjdHVhbFdpZHRoICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFscGhhID0gcGl4W2luZGV4ICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0Ym94ZXMuaGl0Ym94ZXNbXCJcIi5jb25jYXQoeCwgXCItXCIpLmNvbmNhdCh5KV0gPSBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX19hc3NpZ24oX19hc3NpZ24oe30sIGltYWdlKSwgeyBpbWFnZTogaW1nIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHNjYWxlZEltYWdlcy5tYXAobWFrZUltZykpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIG1ha2VDYW52YXMgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdvbmt5IHdpdGggdGhpcyBjb250ZXh0IHlvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW1hZ2UpLCB7IGNhbnZhczogY2FudmFzLCBjdHg6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjYWxlZEltYWdlc1dpdGhJbWFnZXNXaXRoQ2FudmFzZXMgPSBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzLm1hcChtYWtlQ2FudmFzKTtcbiAgICAgICAgICAgICAgICBkcmF3SW1nID0gZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gaW1nLmN0eCwgaW1hZ2UgPSBpbWcuaW1hZ2UsIGxlZnQgPSBpbWcubGVmdCwgdG9wID0gaW1nLnRvcCwgd2lkdGggPSBpbWcud2lkdGgsIGhlaWdodCA9IGltZy5oZWlnaHQsIF9hID0gaW1nLnRpbnQsIHRpbnQgPSBfYSA9PT0gdm9pZCAwID8gbnVsbCA6IF9hLCBjbGVhciA9IGltZy5jbGVhcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGFjdHVhbFdpZHRoLCBhY3R1YWxIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHRpbnQuY29sb3IsIF9iID0gdGludC5hbHBoYSwgYWxwaGEgPSBfYiA9PT0gdm9pZCAwID8gMC41IDogX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmFja0J1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrQnVmZmVyLndpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrQnVmZmVyLmhlaWdodCA9IGFjdHVhbEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBidHggPSBiYWNrQnVmZmVyLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYnR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdvbmt5IHdpdGggdGhpcyBjb250ZXh0IHlvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnR4LmNsZWFyUmVjdCgwLCAwLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgd2UnbGwgbXVsdGlwbHkgYSByZWN0YW5nbGUgb2YgeW91ciBjaG9zZW4gY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcIm11bHRpcGx5XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZmlsbFJlY3QoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImRlc3RpbmF0aW9uLWluXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBidHguZHJhd0ltYWdlKGltYWdlLCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShiYWNrQnVmZmVyLCAwLCAwLCBhY3R1YWxXaWR0aCwgYWN0dWFsSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNjYWxlZEltYWdlc1dpdGhJbWFnZXNXaXRoQ2FudmFzZXMuZm9yRWFjaChmdW5jdGlvbiAoaW1nKSB7IHJldHVybiBkcmF3SW1nKGltZyk7IH0pO1xuICAgICAgICAgICAgICAgIHN0YXRlID0geyBzdGF0ZTogXCJzZWxlY3QtY2F2aXR5XCIgfTtcbiAgICAgICAgICAgICAgICBjbGlja0xvY2sgPSB7IGxvY2s6IG51bGwgfTtcbiAgICAgICAgICAgICAgICByZXNldEJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVzZXRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNldEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNldCBidXR0b24gbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNldEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGlja0xvY2subG9jaykgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNsaWNrTG9jay5sb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHN0YXRlOiBcInNlbGVjdC1jYXZpdHlcIiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmlkLnN0YXJ0c1dpdGgoXCJ0b290aFwiKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZHJhd0ltZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlja0xvY2subG9jayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrTG9jay5sb2NrID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNSZWN0LCB4LCB5LCBoaXRib3hJZCwgaW1hZ2UsIHRhcmdldCwgX2xvb3BfMSwgaSwgaW5zdHJ1Y3Rpb25zQ29udGVudCwgcmVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVjdCA9IGNhbnZhc0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLmZsb29yKGUub2Zmc2V0WCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5mbG9vcihlLm9mZnNldFkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0Ym94SWQgPSBoaXRib3hlcy5oaXRib3hlc1tcIlwiLmNvbmNhdCh4LCBcIi1cIikuY29uY2F0KHkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGl0Ym94SWQpIHJldHVybiBbMyAvKmJyZWFrKi8sIDddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLmZpbmQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gX2EuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkID09PSBoaXRib3hJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWFnZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwYXJzZUludChoaXRib3hJZC5zcGxpdChcIi1cIilbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHN0YXRlLnN0YXRlID09PSBcInNlbGVjdC1jYXZpdHlcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0ltZyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW1hZ2UpLCB7IHRpbnQ6IHsgY29sb3I6IFwiI0YwMDAwMFwiLCBhbHBoYTogMC4zIH0gfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IHN0YXRlOiBcInNlbGVjdC10b290aFwiLCBjYXZpdHk6IHRhcmdldCwgc2VsZWN0ZWQ6IG51bGwgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0YXJnZXQgPCBzdGF0ZS5jYXZpdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuc2VsZWN0ZWQgPT0gbnVsbCB8fCBzdGF0ZS5zZWxlY3RlZCA8IHRhcmdldCkpKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbWFnZV8xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXzEgPSBzY2FsZWRJbWFnZXNXaXRoSW1hZ2VzV2l0aENhbnZhc2VzLmZpbmQoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQgPT09IFwidG9vdGgtXCIuY29uY2F0KGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2VfMSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0ltZyhfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW1hZ2VfMSksIHsgY2xlYXI6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNsZWVwKDE1MCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAoX2EgPSBzdGF0ZS5zZWxlY3RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8PSB0YXJnZXQpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKGkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCArIDEgPT09IHN0YXRlLmNhdml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJ3aW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F2aXR5OiBzdGF0ZS5jYXZpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJzZWxlY3QtdG9vdGhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F2aXR5OiBzdGF0ZS5jYXZpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5zdHJ1Y3Rpb25zLWNvbnRlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc3RydWN0aW9uc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnN0cnVjdGlvbnMgY29udGVudCBhcmVhIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VsZWN0LWNhdml0eVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RydWN0aW9uc0NvbnRlbnQudGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWxlY3QgdGhlIHRvb3RoIHdpdGggdGhlIGNhdml0eSFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZWxlY3QtdG9vdGhcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBzb2x2ZSgyMSAtIHN0YXRlLmNhdml0eSwgMjEgLSAoc3RhdGUuc2VsZWN0ZWQgfHwgMCkpLnJlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudC50ZXh0Q29udGVudCA9IFwiU2VsZWN0IHRoZSBjdXJyZW50bHkgcGxheWVkIHRvb3RoIVxcbklmIGl0J3MgeW91ciB0dXJuLCB0aGVuIHBsYXkgXCIuY29uY2F0KHJlbSB8fCAxLCBcIiFcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2luXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zQ29udGVudC50ZXh0Q29udGVudCA9IFwiSWYgaXQncyB5b3VyIHR1cm4sIHRoZW4geW91J3ZlIHdvbiFcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGlja0xvY2subG9ja107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrTG9jay5sb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTsgfSk7XG4gICAgICAgICAgICAgICAgX2RyYXdIaXRib3hlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBhY3R1YWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHdvbmt5IHdpdGggdGhpcyBjb250ZXh0IHlvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltZyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gaW1nLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGhpdGJveElkIGluIGhpdGJveGVzLmhpdGJveGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBoaXRib3hJZC5zcGxpdChcIi1cIiksIHggPSBfYVswXSwgeSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoeSwgMTApICogYWN0dWFsV2lkdGggKyBwYXJzZUludCh4LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh7IHg6IHgsIHk6IHksIGluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKiA0XSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaW5kZXggKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5tYWluKCk7XG5leHBvcnQge307XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ /* webpack/runtime/getFullHash */
/******/ (() => {
/******/ 	__webpack_require__.h = () => ("e23e4a325388cb61f184")
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ }
);